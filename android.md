## Java相关
#### 1、接口的意义-百度 
规范、扩展、回调
#### 2、抽象类的意义-百度 
1. 为其他子类提供一个公共的类型
2. 封装子类中重复定义的内容
3. 定义抽象方法，子类虽然有不同的实现，但是定义时一致的

#### 3、内部类的作用-乐视
1. 内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立；
2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类；
3. 创建内部类对象的时刻并不依赖于外围类对象的创建；
4. 内部类没有令人疑惑的is-a关系，他就是一个独立的实体；
5. 内部类提供了更好的封装，除了该外围类，其他类都能访问；

#### 4、Java 虚拟机的特性-百度-乐视
Java语言的重要特性是平台无关性，而使用Java虚拟机是实现这一特点的关键，一般的高级语言要想运行在不同的平台上，至少需要编译成不同的目标代码，而引入Java语言虚拟机后，Java语言在不同平台运行时不需要重新编译。Java语言屏蔽了和具体平台相关的信息，使Java语言编译程序只需生成在Java虚拟机上运行的目标码（字节码），就可以在多个平台不加修改的运行。Java虚拟机在执行字节码的时候再将字节码解释成具体平台的机器指令运行。

#### 5、哪些情况下的对象会被垃圾回收机制处理掉-美团-小米
Java垃圾回收机制最基本的做法就是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在不同的世代区域中，一般实现的世代为3个：年轻、年老、永久。内存的分配是发生在年轻世代中的，当一个对象的存活时间足够长的时候，它就会被复制到年老的世代中。对于不同世代可以使用不同的回收算法，进行世代划分的出发点是对应用中对象存活时间进行研究后得出统计规律。一般来说，一个应用中大部分对象的存活时间都很短，比如局部变量的存活时间就只在方法的执行过程中，基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。

#### 6、进程和线程的区别-猎豹-美团
> 一个程序至少有一个进程，一个进程至少有一个线程

- 线程的划分尺度小于进程，使得多线程程序的并发性更高
- 进程在执行的过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率
- 线程在执行的过程中和进程有区别，每个独立的线程有一个程序运行的入口、顺序执行序列和程序出口，但是线程不能独立执行，必须依存于应用程序中，由应用程序提供多线程控制。
- 从逻辑的角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是操作系统并不会将多个线程看做多个独立运行的应用程序来实现资源的调度和分配，这就是进程和线程的重要区别。
- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
- 线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的独立运行的基本单位。线程自己基本上不拥有系统资源，只是拥有一些在程序中必不可少的资源，比如程序计数器、寄存器、栈，但是它与同属一个进程的其他线程共享进程所拥有的其他资源。
- 一个线程可以创建和销毁另一个线程，同一个进程中的多个线程可以并发执行。

#### 7、Java中==和equals和hashCode的区别-乐视
==是运算符，用于比较两个变量是否相等。
equals，是Objec类的方法，用于比较两个对象是否相等。

#### 8、HashMap的实现原理-美团 
- HashMap：是基于哈希表的map接口的非同步实现，此实现提供所有可选映射操作，并允许null值和null键。此类不保证映射的顺序，特别是它不保证该顺序永恒不变。
- HashMap的数据结构：在Java编程语言中，最基本的结构就是两种，一个是数组，另一个是模拟指针（引用），所有的数据结构都可以用着两种数据结构来构造，HashMap实际上是“链表散列”的数据结构，即数组和链表的结合体。

#### 9、String-StringBuffer-StringBuilder区别-小米-乐视-百度
- String 字符串常量
- StringBuffer 字符串变量（线程安全）
- StringBuilder 字符串变量（非线程安全）

- String类型和StringBuffer类型的主要区别在于，String的不可变的对象，因此在每次对String类型进行改变的时候都等同于生成了一个新的String对象，然后将指针指向了新的String对象，所以经常改变内容的字符串最好不要用String类型，这会导致JVM的GC开始工作，速度会相当慢。
而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：
``` java    
String S1 = "This is only a" + 
    "simple" + " test";
StringBuffer Sb = new StringBuffer("This is only a")
    .append("simple").append("test");
```
- 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个 String S1 = “This is only a” + “ simple” + “test”; 其实就是： String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如： String S2 = “This is only a”; String S3 = “ simple”; String S4 = “ test”; String S1 = S2 +S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做
- 在大部分情况下的效率都是 StringBuffer > String
1. Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。
2. 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。
3. StringBuffer上的主要操作是append和insert，可以重载这些方法来接收任意类型的数据，每个方法都能高效的将给定数据转化成字符串，然后将该字符串的追加或者插入到字符串缓冲区中。append始终将字符串添加到缓冲区末端，insert方法将插入到指定位置。
- 在大部分情况下 StringBuilder > StringBuffer
1. java.lang.StringBuilder一个可变的字符序列是Java5新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

#### 10、什么导致线程阻塞-58-美团
- 为了解决对共享存储区的访问冲突，Java引入了同步机制，现在考察多线程对共享资源的访问，显然同步机制已经不够，因为在任意时刻所要求的资源并不一定已经准备好了被访问，反过来，同一时间已经被准备好的资源也不一定是一个。为了解决这个问题，Java引入了对阻塞机制的支持。
- 阻塞指的是暂停一个线程的执行等待某个条件的发生。
1. sleep()方法：指定以毫秒为单位的一段时间为参数，使得线程在指定时间内进入阻塞状态，不能得到CPU时间，指定的时间一过，线程重新进入可执行的状态。典型的，sleep()被用在等待某个资源就绪的情况下，测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止；
2. suspend()和resume()方法：这两个方法要配套使用。suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型的，suspend()和resume()被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。
3. yield()方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。
4. wait()和notify()方法：两个方法配套使用，wait()使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者将对应的notify()被调用或者超出指定时间线程重新进入可执行状态，后者则必须对应notify()调用。

初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。

#### 11、多线程同步机制-猎豹
#### 12、ArrayMap对比HashMap
#### 13、hashmap和hashtable的区别-乐视-小米-360
#### 14、容器类之间的区别-乐视-美团
#### 15、抽象类接口区别-360

## Android 方面（问题答案在下文）
#### 16、如何导入外部数据库？
#### 17、本地广播和全局广播有什么差别？
#### 18、intentService作用是什么,AIDL解决了什么问题-小米
#### 19、Ubuntu编译安卓系统-百度
#### 20、LaunchMode应用场景-百度-小米-乐视
#### 21、Touch事件传递流程-小米
#### 22、View绘制流程-百度
![image](https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/view_touch_ignorant.png?raw=true)
![image](https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/view_touch_interested.png?raw=true)
![image](https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/view_touch_interested.png?raw=true)
#### 23、多线程-360
#### 24、Handler,Thread和HandlerThread的差别-小米
#### 25、线程同步-百度
#### 26、什么情况导致内存泄漏-美团
#### 27、ANR定位和修正
#### 28、什么情况导致oom-乐视-美团
#### 29、Service与Activity之间通信的几种方式
#### 30、如何保证Service在后台不被Kill
#### 31、Requestlayout,onlayout,onDraw,DrawChild区别与联系-猎豹
#### 32、Android动画框架实现原理
#### 33、Android为每个应用程序分配的内存大小是多少-美团
#### 34、优化自定义View百度-乐视-小米
#### 36、Volley-美团-乐视
#### 37、Glide源码解析
#### 38、Android设计模式
#### 39、Android属性动画特性-乐视-小米
#### 40、Activity Window View三者的差别,fragment的特点-360
#### 41、invalidate和postInvalidate的区别及使用-百度
#### 42、LinearLayout和RelativeLayout性能对比-百度
#### 43、View刷新机制-百度-美团
#### 44、架构设计-搜狐

## 腾讯公司面试题精选
#### 45、2000万个整数，找出第五十大的数字？
#### 46、从网络加载一个10M的图片，说下注意事项
#### 47、自定义View注意事项
#### 48、项目中常用的设计模式
#### 49、JVM的理解

## 阿里面试题精选
#### 50、进程间通信方式
#### 51、什么是协程
#### 52、内存泄露是怎么回事
#### 53、程序计数器，引到了逻辑地址（虚地址）和物理地址及其映射关系
#### 54、数组和链表的区别
#### 55、二叉树的深度优先遍历和广度优先遍历的具体实现
#### 56、堆的结构
#### 57、bitmap对象的理解
#### 58、什么是深拷贝和浅拷
#### 59、对象锁和类锁是否会互相影响
#### 60、looper架构
#### 61、自定义控件原理
#### 62、ActivityThread，Ams，Wms的工作原理
#### 63、Java中final，finally，finalize的区别
#### 64、一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法
#### 65、两个进程同时要求写或者读，能不能实现？如何防止进程的同步？
#### 66、volatile 的意义？